#include "ball.h"
#include "../data/DataCenter.h"
#include "../data/ImageCenter.h"
#include "../shapes/Circle.h"
#include <allegro5/bitmap_draw.h>
#include "Normall.h"
#include "../Level.h"
enum class Dir {
	UP, DOWN, LEFT, RIGHT
};
namespace BallSetting
{
    static constexpr char png_root_path[40] = {
        "../assets/image/ball/IDR_GIF3.png",
    };
    static constexpr char dir_path_prefix[][10] = {
        "UP", "DOWN", "LEFT", "RIGHT"
    };
};


Ball *Ball::create_ball(BallState type, const std::vector<Point> &path)
{
    switch(type)
    {
        case BallState::NORMAL:
        {
            return new Normal{path};
        }
    }
}

Dir convert_dir_ball(const Point &v)
{
    if(v.y<0&&abs(v.y)>=abs(v.x))
    {
        return Dir::UP;
    }
    else if(v.y>0&&abs(v.y)>=abs(v.x))
    {
        return Dir::DOWN;
    }
    else if(v.x<0&&abs(v.x)>=abs(v.y))
    {
        return Dir::LEFT;
    }
    else
    {
        return Dir::RIGHT;
    }
}
void
Ball::update() {
	DataCenter *DC = DataCenter::get_instance();
	ImageCenter *IC = ImageCenter::get_instance();

	// After a period, the bitmap for this monster should switch from (i)-th image to (i+1)-th image to represent animation.
	if(bitmap_switch_counter) --bitmap_switch_counter;
	else {
		bitmap_img_id = (bitmap_img_id + 1) % (bitmap_img_ids[static_cast<int>(dir)].size());
		bitmap_switch_counter = bitmap_switch_freq;
	}
	// v (velocity) divided by FPS is the actual moving pixels per frame.
	double movement = speed / DC->FPS;
	// Keep trying to move to next destination in "path" while "path" is not empty and we can still move.
	while(!path.empty() && movement > 0) {
		const Point &grid = this->path.front();
		const Circle &region = DC->level->grid_to_region(grid, 10);
		const Point &next_goal = Point{region.center_x(), region.center_y()};

		// Extract the next destination as "next_goal". If we want to reach next_goal, we need to move "d" pixels.
		double d = Point::dist(Point{shape->center_x(), shape->center_y()}, next_goal);
		Dir tmpdir;
		if(d < movement) {
			// If we can move more than "d" pixels in this frame, we can directly move onto next_goal and reduce "movement" by "d".
			movement -= d;
			tmpdir = convert_dir_ball(Point{next_goal.x - shape->center_x(), next_goal.y - shape->center_y()});
			shape.reset(new Circle{next_goal.x, next_goal.y, 10.0});
			path.pop();
		} else {
			// Otherwise, we move exactly "movement" pixels.
			double dx = (next_goal.x - shape->center_x()) / d * movement;
			double dy = (next_goal.y - shape->center_y()) / d * movement;
			tmpdir = convert_dir_ball(Point{dx, dy});
			shape->update_center_x(shape->center_x() + dx);
			shape->update_center_y(shape->center_y() + dy);
			movement = 0;
		}
		// Update facing direction.
		dir = tmpdir;
	}

    char buffer[50];
	sprintf(
		buffer, "IDR_GIF3.png",
		BallSetting::png_root_path[static_cast<int>(state)],
		BallSetting::dir_path_prefix[static_cast<int>(dir)],
		bitmap_img_ids[static_cast<int>(dir)][bitmap_img_id]);
	// Update real hit box for monster.
	ALLEGRO_BITMAP *bitmap = IC->get(BallSetting::png_root_path);
	const double &cx = shape->center_x();
	const double &cy = shape->center_y();
	// We set the hit box slightly smaller than the actual bounding box of the image because there are mostly empty spaces near the edge of a image.
	const int &h = al_get_bitmap_width(bitmap) * 0.8;
	const int &w = al_get_bitmap_height(bitmap) * 0.8;
	shape.reset(new Circle{
        (cx - w / 2.), (cy - h / 2.),10.0
    });
}

void
Ball::draw() {
	ImageCenter *IC = ImageCenter::get_instance();
	ALLEGRO_BITMAP *bitmap = IC->get(BallSetting::png_root_path);
	al_draw_bitmap(
		bitmap,
		shape->center_x() - al_get_bitmap_width(bitmap) / 2,
		shape->center_y() - al_get_bitmap_height(bitmap) / 2, 0);
}
